<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Flappy Jollibee ÂÆåÂÖ®Áâà</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: url('background.jpg') no-repeat center center / cover;
      overflow: hidden; touch-action: none; user-select: none;
    }
    canvas {
      display: block;
      background: transparent;
    }
    #restartButton {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 30px 60px;
      font-size: 28px;
      background-color: #f44336;
      color: white;
      border: none;
      border-radius: 12px;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<button id="restartButton">„É™„Çπ„Çø„Éº„Éà</button>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const restartButton = document.getElementById('restartButton');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

function isMobile() {
  return /Mobi|Android/i.test(navigator.userAgent);
}

let jollibeeY = canvas.height / 2;
let velocity = 0;
const gravity = isMobile() ? 0.6 : 0.4;
const jumpStrength = isMobile() ? -10 : -8;
let gameOver = false;
let gameStarted = false;
let score = 0;
const goalScore = 10;
let clear = false;

const jollibeeImg = new Image();
jollibeeImg.src = 'jollibee.png';

const jollibeeSize = Math.min(canvas.width, canvas.height) / 10;
const jollibeeWidth = jollibeeSize;
const jollibeeHeight = jollibeeSize * 1.5;

let pipes = [];
let items = [];
let floatingTexts = [];

const pipeWidth = jollibeeSize * 1.2;
const pipeGap = jollibeeSize * 3;
const pipeSpeed = 2;

const emojis = [
  { emoji: 'üçó', value: 100 },
  { emoji: 'üçù', value: 5 },
  { emoji: 'üçî', value: -200 },
];

function spawnPipe() {
  const topHeight = Math.random() * (canvas.height - pipeGap - jollibeeSize * 2) + jollibeeSize;
  pipes.push({ x: canvas.width, topHeight, counted: false });

  if (Math.random() < 0.3) {
    const item = emojis[Math.floor(Math.random() * emojis.length)];
    items.push({
      x: canvas.width,
      y: topHeight + pipeGap / 2,
      emoji: item.emoji,
      value: item.value,
      collected: false
    });
  }
}
function drawJollibee() {
  ctx.drawImage(jollibeeImg, canvas.width * 0.2, jollibeeY, jollibeeWidth, jollibeeHeight);
}

function drawPipes() {
  ctx.fillStyle = 'green';
  pipes.forEach(pipe => {
    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
    ctx.fillRect(pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvas.height - pipe.topHeight - pipeGap);
  });
}

function drawItems() {
  ctx.font = `${jollibeeSize}px sans-serif`;
  items.forEach(item => {
    ctx.fillText(item.emoji, item.x, item.y);
  });
}

function drawFloatingTexts() {
  ctx.font = `${jollibeeSize * 0.6}px sans-serif`;
  ctx.fillStyle = 'yellow';
  floatingTexts.forEach(text => {
    ctx.fillText(text.text, text.x, text.y);
  });
}

function drawText(text, size, y) {
  ctx.fillStyle = 'white';
  ctx.font = `${size}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(text, canvas.width / 2, y);
}

function checkCollision() {
  const x = canvas.width * 0.2;
  const padding = 10;
  for (let pipe of pipes) {
    if (
      x + jollibeeWidth - padding > pipe.x &&
      x + padding < pipe.x + pipeWidth &&
      (jollibeeY + padding < pipe.topHeight || jollibeeY + jollibeeHeight - padding > pipe.topHeight + pipeGap)
    ) {
      gameOver = true;
    }
    if (!pipe.counted && pipe.x + pipeWidth < x) {
      score++;
      pipe.counted = true;
    }
  }

  items.forEach(item => {
    if (
      !item.collected &&
      x + jollibeeWidth > item.x &&
      x < item.x + jollibeeSize &&
      jollibeeY < item.y &&
      jollibeeY + jollibeeHeight > item.y - jollibeeSize
    ) {
      score += item.value;
      item.collected = true;
      floatingTexts.push({
        text: (item.value > 0 ? "+" : "") + item.value + "pt",
        x: item.x,
        y: item.y,
        alpha: 1.0
      });
    }
  });

  if (jollibeeY + jollibeeHeight > canvas.height || jollibeeY < 0) {
    gameOver = true;
  }
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!gameStarted) {
    drawText('Flappy Jollibee üçóüçùüçî', canvas.height * 0.06, canvas.height * 0.25);
    drawText('üçó +100  üçù +5  üçî -200', canvas.height * 0.035, canvas.height * 0.33);
    drawText('ÁîªÈù¢„Çø„ÉÉ„Éó„Åß„Çπ„Çø„Éº„Éà', canvas.height * 0.035, canvas.height * 0.4);
    requestAnimationFrame(update);
    return;
  }

  if (!gameOver && !clear) {
    velocity += gravity;
    jollibeeY += velocity;

    pipes.forEach(pipe => pipe.x -= pipeSpeed);
    items.forEach(item => item.x -= pipeSpeed);

    if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - canvas.width / 2) {
      spawnPipe();
    }

    pipes = pipes.filter(pipe => pipe.x + pipeWidth > 0);
    items = items.filter(item => item.x + jollibeeSize > 0 && !item.collected);
    floatingTexts.forEach(text => {
      text.y -= 1;
      text.alpha -= 0.02;
    });
    floatingTexts = floatingTexts.filter(text => text.alpha > 0);

    checkCollision();
  }

  drawJollibee();
  drawPipes();
  drawItems();
  drawFloatingTexts();
  drawText(`„Çπ„Ç≥„Ç¢: ${score} pt`, canvas.height * 0.035, canvas.height * 0.08);

  if (gameOver) {
    drawText('GAME OVER', canvas.height * 0.06, canvas.height / 2);
    showRestartButton();
  } else if (score >= goalScore && !clear) {
    clear = true;
    drawText('üéâ „Éû„Éã„É©„ÅßÂæÖ„Å£„Å¶„Çã„ÅûÔºÅüéâ', canvas.height * 0.06, canvas.height / 2);
    showRestartButton();
  }

  requestAnimationFrame(update);
}

function jump() {
  if (!gameStarted) {
    gameStarted = true;
    pipes = [];
    items = [];
    floatingTexts = [];
    score = 0;
  }

  if (!gameOver && !clear) {
    velocity = jumpStrength;
  }
}

function showRestartButton() {
  restartButton.style.display = 'block';
}
function hideRestartButton() {
  restartButton.style.display = 'none';
}
function restartGame() {
  jollibeeY = canvas.height / 2;
  velocity = 0;
  pipes = [];
  items = [];
  floatingTexts = [];
  score = 0;
  gameOver = false;
  clear = false;
  gameStarted = false;
  hideRestartButton();
}

canvas.addEventListener('touchstart', jump);
restartButton.addEventListener('click', restartGame);
jollibeeImg.onload = () => {
  update();
};
</script>
</body>
</html>

